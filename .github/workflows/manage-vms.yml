name: Manage vSphere VMs

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - add
          - remove
          - list
          - apply
        default: 'list'
      vm_name:
        description: 'VM name (identifier in configuration)'
        required: false
        type: string
      network_type:
        description: 'Network type'
        required: false
        type: choice
        options:
          - static
          - dhcp
        default: 'static'
      ip_address:
        description: 'IP address (required for static IP)'
        required: false
        type: string
      subnet_mask:
        description: 'Subnet mask (CIDR notation, e.g. "24")'
        required: false
        type: string
        default: '24'
      ssh_public_key:
        description: 'SSH public key for the ubuntu user'
        required: false
        type: string

env:
  # vSphere credentials from secrets
  VSPHERE_SERVER: ${{ secrets.VSPHERE_SERVER }}
  VSPHERE_USER: ${{ secrets.VSPHERE_USER }}
  VSPHERE_PASSWORD: ${{ secrets.VSPHERE_PASSWORD }}

  # MinIO configuration - from secrets or default values
  MINIO_ENDPOINT: ${{ secrets.MINIO_ENDPOINT || 'http://minio.local' }}
  MINIO_ACCESS_KEY: ${{ secrets.MINIO_ACCESS_KEY || 'minioadmin' }}
  MINIO_SECRET_KEY: ${{ secrets.MINIO_SECRET_KEY || 'minioadmin' }}
  MINIO_BUCKET: ${{ secrets.MINIO_BUCKET || 'terraform-state' }}
  MINIO_OBJECT_PATH: "vm-configs.json"  # Changed from subfolder to file directly

jobs:
  manage-vms:
    runs-on: self-hosted

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Verify Terraform is installed
        run: |
          terraform --version
          echo "Using existing Terraform installation on the runner"

      - name: Set parameters
        id: params
        run: |
          # Directly use workflow dispatch inputs
          echo "action=${{ github.event.inputs.action }}" >> $GITHUB_OUTPUT
          echo "vm_name=${{ github.event.inputs.vm_name }}" >> $GITHUB_OUTPUT
          echo "network_type=${{ github.event.inputs.network_type }}" >> $GITHUB_OUTPUT
          echo "ip_address=${{ github.event.inputs.ip_address }}" >> $GITHUB_OUTPUT
          echo "subnet_mask=${{ github.event.inputs.subnet_mask }}" >> $GITHUB_OUTPUT
          echo "ssh_public_key=${{ github.event.inputs.ssh_public_key }}" >> $GITHUB_OUTPUT

      - name: Pull VM configurations from MinIO
        id: pull_configs
        if: steps.params.outputs.action != 'list'
        run: |
          # Create the destination directory
          mkdir -p ./terraform/environments/dev

          # Configure MinIO client with proper alias
          echo "Configuring MinIO client..."
          mc alias set myminio http://minio.local minioadmin minioadmin

          # Verify MinIO connectivity and debug output
          echo "Testing MinIO connectivity..."
          mc ls myminio/ || echo "Failed to list MinIO root"

          echo "Listing terraform-state bucket contents..."
          mc ls myminio/terraform-state/ || echo "Failed to list bucket contents"

          # Pull configurations from MinIO using temporary file first
          echo "Pulling configurations from MinIO..."
          TEMP_FILE="/tmp/terraform.tfvars.json"
          FINAL_PATH="$(pwd)/terraform/environments/dev/terraform.tfvars.json"

          if mc cp myminio/terraform-state/vm-configs.json "$TEMP_FILE"; then
            echo "Successfully downloaded from MinIO"
            cp "$TEMP_FILE" "$FINAL_PATH"
          else
            echo "Failed to copy from MinIO, creating default configuration..."
            echo '{"vm_configs": {}}' > "$FINAL_PATH"
          fi

          # Display the current configurations
          echo "Current VM configurations:"
          cat ./terraform/environments/dev/terraform.tfvars.json | jq .

      - name: List VM inventory (for list action only)
        if: steps.params.outputs.action == 'list'
        id: list_vms
        run: |
          # Set govc environment variables for vSphere API access
          export GOVC_URL="https://${{ secrets.VSPHERE_SERVER }}"
          export GOVC_USERNAME="${{ secrets.VSPHERE_USER }}"
          export GOVC_PASSWORD="${{ secrets.VSPHERE_PASSWORD }}"
          export GOVC_INSECURE=true  # Skip certificate verification for lab environments

          echo "Listing VMs from vSphere inventory..."
          echo "VM Paths:"
          govc ls -l 'vm/*'

          echo "Detailed VM Information:"
          govc vm.info '*'

          echo "VM power states:"
          govc find . -type m -runtime.powerState on

          echo "Network information:"
          govc vm.network.info '*'

          # Save list for summary
          echo "CONFIGS_SAVED=false" >> $GITHUB_ENV
          echo "VM_LIST_ACTION=true" >> $GITHUB_ENV

      - name: Run VM management script (add/remove/apply actions)
        if: steps.params.outputs.action != 'list'
        id: vm_management
        run: |
          # Make the script executable
          chmod +x ./scripts/manage_vms.sh

          # Get parameters from previous step
          ACTION="${{ steps.params.outputs.action }}"
          VM_NAME="${{ steps.params.outputs.vm_name }}"
          NETWORK_TYPE="${{ steps.params.outputs.network_type }}"
          IP_ADDRESS="${{ steps.params.outputs.ip_address }}"
          SUBNET_MASK="${{ steps.params.outputs.subnet_mask }}"
          SSH_PUBLIC_KEY="${{ steps.params.outputs.ssh_public_key }}"

          # Set required environment variables
          export TF_VAR_vsphere_user="${{ secrets.VSPHERE_USER }}"
          export TF_VAR_vsphere_password="${{ secrets.VSPHERE_PASSWORD }}"
          export TF_VAR_vsphere_server="${{ secrets.VSPHERE_SERVER }}"
          export TF_VAR_ssh_public_key="$SSH_PUBLIC_KEY"
          export GOVC_URL="https://${{ secrets.VSPHERE_SERVER }}"
          export GOVC_USERNAME="${{ secrets.VSPHERE_USER }}"
          export GOVC_PASSWORD="${{ secrets.VSPHERE_PASSWORD }}"
          export GOVC_INSECURE=true
          export AWS_ACCESS_KEY_ID="${{ secrets.MINIO_ACCESS_KEY || env.MINIO_ACCESS_KEY }}"
          export AWS_SECRET_ACCESS_KEY="${{ secrets.MINIO_SECRET_KEY || env.MINIO_SECRET_KEY }}"
          export AWS_REGION="us-east-1"
          export AWS_DEFAULT_REGION="us-east-1"
          export AWS_EC2_METADATA_DISABLED="true"

          echo "Running with: ACTION=$ACTION, VM_NAME=$VM_NAME, NETWORK_TYPE=$NETWORK_TYPE"
          if [[ "$NETWORK_TYPE" == "static" ]]; then
            echo "Static IP: $IP_ADDRESS/$SUBNET_MASK"
          fi

          # Initialize Terraform
          cd terraform/environments/dev
          terraform init -upgrade

          # Run manage_vms.sh script
          cd ../../../
          bash ./scripts/manage_vms.sh \
            --action="$ACTION" \
            --vm-name="$VM_NAME" \
            --network-type="$NETWORK_TYPE" \
            --ip-address="$IP_ADDRESS" \
            --subnet-mask="$SUBNET_MASK" \
            --ssh-public-key="$SSH_PUBLIC_KEY"

          # Always run apply after add/remove operations
          if [[ "$ACTION" == "add" || "$ACTION" == "remove" ]]; then
            echo "Running apply operation to apply configuration changes..."
            bash ./scripts/manage_vms.sh --action=apply
          fi

          # Save and push VM configurations
          if [[ -f "./terraform/environments/dev/terraform.tfvars.json" ]]; then
            cp ./terraform/environments/dev/terraform.tfvars.json /tmp/vm_configs.json
            TEMP_FILE="/tmp/terraform-updated.tfvars.json"
            cp ./terraform/environments/dev/terraform.tfvars.json "$TEMP_FILE"

            # Configure MinIO client
            mc alias set myminio "${{ secrets.MINIO_ENDPOINT || env.MINIO_ENDPOINT }}" \
               "${{ secrets.MINIO_ACCESS_KEY || env.MINIO_ACCESS_KEY }}" \
               "${{ secrets.MINIO_SECRET_KEY || env.MINIO_SECRET_KEY }}"

            # Push configuration to MinIO if bucket exists
            if mc ls myminio/ &>/dev/null; then
              if ! mc ls myminio/"${{ env.MINIO_BUCKET }}/" &>/dev/null; then
                mc mb myminio/"${{ env.MINIO_BUCKET }}/" || echo "MINIO_PUSH_STATUS=failed" >> $GITHUB_ENV
              fi

              if mc cp "$TEMP_FILE" myminio/"${{ env.MINIO_BUCKET }}"/"${{ env.MINIO_OBJECT_PATH }}"; then
                echo "MINIO_PUSH_STATUS=success" >> $GITHUB_ENV
              else
                echo "MINIO_PUSH_STATUS=failed" >> $GITHUB_ENV
              fi
            else
              echo "MINIO_PUSH_STATUS=failed" >> $GITHUB_ENV
            fi

            echo "CONFIGS_SAVED=true" >> $GITHUB_ENV
          else
            echo "CONFIGS_SAVED=false" >> $GITHUB_ENV
          fi

      - name: Wait for VMs to come online and verify accessibility
        if: |
          env.CONFIGS_SAVED == 'true' &&
          (steps.params.outputs.action == 'add' || steps.params.outputs.action == 'apply') &&
          steps.params.outputs.action != 'list'
        id: wait_for_vms
        run: |
          # Create a status file for the summary
          echo '[]' > /tmp/vm_status.json
          VM_CONFIGS=$(jq -r '.vm_configs' /tmp/vm_configs.json)
          STATUS_ARRAY=()

          # Wait for VMs to initialize
          echo "Waiting 60 seconds for VMs to complete initialization..."
          sleep 60

          # Check each VM
          for VM_KEY in $(echo "$VM_CONFIGS" | jq -r 'keys[]'); do
            VM_NAME=$(echo "$VM_CONFIGS" | jq -r ".[\"$VM_KEY\"].name")
            NETWORK_TYPE=$(echo "$VM_CONFIGS" | jq -r ".[\"$VM_KEY\"].network_type")

            if [[ "$NETWORK_TYPE" == "static" ]]; then
              IP_ADDRESS=$(echo "$VM_CONFIGS" | jq -r ".[\"$VM_KEY\"].ip_address")
              SSH_COMMAND="ssh ubuntu@$IP_ADDRESS"

              # Check SSH port
              if timeout 10 bash -c "</dev/tcp/$IP_ADDRESS/22" &>/dev/null; then
                STATUS="Online"
                SSH_STATUS="Available"
              else
                STATUS="Pending"
                SSH_STATUS="Unavailable"
              fi

              # Add to status array
              STATUS_ARRAY+=("$(jq -n \
                --arg name "$VM_NAME" \
                --arg key "$VM_KEY" \
                --arg ip "$IP_ADDRESS" \
                --arg status "$STATUS" \
                --arg ssh_status "$SSH_STATUS" \
                --arg ssh_command "$SSH_COMMAND" \
                '{name: $name, key: $key, ip: $ip, status: $status, ssh_status: $ssh_status, ssh_command: $ssh_command}')")
            else
              # For DHCP VMs
              STATUS_ARRAY+=("$(jq -n \
                --arg name "$VM_NAME" \
                --arg key "$VM_KEY" \
                --arg ip "DHCP" \
                --arg status "Unknown (DHCP)" \
                --arg ssh_status "Unknown" \
                --arg ssh_command "N/A - DHCP" \
                '{name: $name, key: $key, ip: $ip, status: $status, ssh_status: $ssh_status, ssh_command: $ssh_command}')")
            fi
          done

          # Save status array to file
          echo '[]' > /tmp/vm_status.json
          for item in "${STATUS_ARRAY[@]}"; do
            jq --argjson item "$item" '. += [$item]' /tmp/vm_status.json > /tmp/vm_status.json.tmp
            mv /tmp/vm_status.json.tmp /tmp/vm_status.json
          done

      - name: Generate summary
        if: always()
        run: |
          echo "# VM Management Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Action Performed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get the action and parameters from the params step
          ACTION="${{ steps.params.outputs.action }}"
          VM_NAME="${{ steps.params.outputs.vm_name }}"
          NETWORK_TYPE="${{ steps.params.outputs.network_type }}"
          IP_ADDRESS="${{ steps.params.outputs.ip_address }}"
          SUBNET_MASK="${{ steps.params.outputs.subnet_mask }}"
          SSH_PUBLIC_KEY="${{ steps.params.outputs.ssh_public_key }}"

          echo "- **Action:** \`$ACTION\`" >> $GITHUB_STEP_SUMMARY

          if [[ "$ACTION" == "list" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## VM Inventory" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "VM listing was performed using direct vSphere API calls via govc. No Terraform operations were executed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "See job logs for complete VM inventory details including paths, power states, and network information." >> $GITHUB_STEP_SUMMARY
            exit 0  # Skip the rest of the summary for list action
          fi

          if [[ "$ACTION" == "add" ]]; then
            echo "- **VM Added:** \`$VM_NAME\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Network Type:** \`$NETWORK_TYPE\`" >> $GITHUB_STEP_SUMMARY
            if [[ "$NETWORK_TYPE" == "static" ]]; then
              echo "- **IP Address:** \`$IP_ADDRESS/$SUBNET_MASK\`" >> $GITHUB_STEP_SUMMARY
            fi
          elif [[ "$ACTION" == "remove" ]]; then
            echo "- **VM Removed:** \`$VM_NAME\`" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          # Add current VM status if available
          if [[ -f "/tmp/vm_status.json" ]]; then
            echo "## Current VMs" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| VM Key | Name | IP Address | Status | SSH | Access Command |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|------|------------|--------|-----|---------------|" >> $GITHUB_STEP_SUMMARY

            # Process the status file with better error handling
            if jq -e . /tmp/vm_status.json > /dev/null 2>&1; then
              # Process the status file and add each VM to the table
              jq -r '.[] | "| \(.key) | \(.name) | \(.ip) | \(.status) | \(.ssh_status) | `\(.ssh_command)` |"' /tmp/vm_status.json >> $GITHUB_STEP_SUMMARY || {
                echo "| ⚠️ Error | Error processing status file | - | - | - | - |" >> $GITHUB_STEP_SUMMARY
                echo "Error details: Invalid JSON format in status file" >> $GITHUB_STEP_SUMMARY
              }
            else
              echo "| ⚠️ Error | Error processing status file | - | - | - | - |" >> $GITHUB_STEP_SUMMARY
              echo "Error details: Invalid JSON format in status file" >> $GITHUB_STEP_SUMMARY
            fi

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Access Instructions" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "For VMs with SSH available:" >> $GITHUB_STEP_SUMMARY
            echo "1. Make sure you have the appropriate SSH key configured" >> $GITHUB_STEP_SUMMARY
            echo "2. Use the access command shown in the table above" >> $GITHUB_STEP_SUMMARY

          elif [[ "${{ env.CONFIGS_SAVED }}" == "true" ]]; then
            echo "## Current VM Configurations" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| VM Key | Name | Network Type | IP Address |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|------|-------------|------------|" >> $GITHUB_STEP_SUMMARY

            # Process the configurations with better error handling
            if [[ -f "/tmp/vm_configs.json" ]] && jq -e . /tmp/vm_configs.json > /dev/null 2>&1; then
              # Process the configurations and add each VM to the table
              VM_CONFIGS=$(jq -r '.vm_configs' /tmp/vm_configs.json)
              for VM_KEY in $(echo "$VM_CONFIGS" | jq -r 'keys[]' 2>/dev/null || echo ""); do
                if [[ -n "$VM_KEY" ]]; then
                  VM_NAME=$(echo "$VM_CONFIGS" | jq -r ".[\"$VM_KEY\"].name" 2>/dev/null || echo "Unknown")
                  NETWORK_TYPE=$(echo "$VM_CONFIGS" | jq -r ".[\"$VM_KEY\"].network_type" 2>/dev/null || echo "Unknown")
                  if [[ "$NETWORK_TYPE" == "static" ]]; then
                    IP_ADDRESS=$(echo "$VM_CONFIGS" | jq -r ".[\"$VM_KEY\"].ip_address" 2>/dev/null || echo "Unknown")
                    SUBNET_MASK=$(echo "$VM_CONFIGS" | jq -r ".[\"$VM_KEY\"].subnet_mask // \"24\"" 2>/dev/null || echo "24")
                    echo "| $VM_KEY | $VM_NAME | $NETWORK_TYPE | $IP_ADDRESS/$SUBNET_MASK |" >> $GITHUB_STEP_SUMMARY
                  else
                    echo "| $VM_KEY | $VM_NAME | $NETWORK_TYPE | DHCP |" >> $GITHUB_STEP_SUMMARY
                  fi
                fi
              done
            else
              echo "| ⚠️ Error | Error processing configuration file | - | - |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "No VM configurations found." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## MinIO Configuration Storage" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "VM configurations are stored in MinIO at:" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** \`${{ env.MINIO_ENDPOINT }}/${{ env.MINIO_BUCKET }}/${{ env.MINIO_OBJECT_PATH }}\`" >> $GITHUB_STEP_SUMMARY

          # Add push status if available
          if [[ "${{ env.MINIO_PUSH_STATUS }}" == "success" ]]; then
            echo "- **Status:** ✅ Successfully pushed to MinIO" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ env.MINIO_PUSH_STATUS }}" == "failed" ]]; then
            echo "- **Status:** ❌ Failed to push to MinIO" >> $GITHUB_STEP_SUMMARY
          fi
