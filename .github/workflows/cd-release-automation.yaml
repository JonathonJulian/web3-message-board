---
name: Release Automation
run-name: ${{  github.event.inputs.release_type || 'Auto'  }} Release ${{  github.event.inputs.version && format('v{0}', github.event.inputs.version) || '(version to be determined)'  }}

on:
  push:
    branches: [main]
  repository_dispatch:
    types: [docker-build-complete]
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g. 1.0.0)"
        required: false
        type: string
      release_type:
        description: "Type of release"
        type: choice
        options:
          - Major
          - Minor
          - Patch
        default: "Patch"
        required: true
      create_github_release:
        description: "Create GitHub Release"
        type: boolean
        default: true
      deploy_artifacts:
        description: "Deploy artifacts"
        type: boolean
        default: true
      build_docker:
        description: "Build Docker images"
        type: boolean
        default: true
      build_arm:
        description: "Build ARM64 architecture"
        type: boolean
        default: false

# Add explicit write permissions
permissions:
  contents: write
  pull-requests: write
  discussions: write
  actions: write

jobs:
  # Analyze commits to determine version bump type
  analyze-commits:
    runs-on: ubuntu-latest
    outputs:
      release_type: ${{  steps.analyze.outputs.release_type  }}
      has_new_commits: ${{  steps.analyze.outputs.has_new_commits  }}
    if: github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{  github.token  }}

      - name: Analyze commits for release type
        id: analyze
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Get commit messages since the latest tag
          COMMITS=$(git log --pretty=format:"%s" $LATEST_TAG..HEAD)
          COMMIT_COUNT=$(echo "$COMMITS" | grep -v "^$" | wc -l | xargs)
          echo "Found $COMMIT_COUNT new commits since $LATEST_TAG"

          echo "Commit messages since last tag:"
          git log --pretty=format:"%h - %s" $LATEST_TAG..HEAD

          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "No new commits found"
            echo "has_new_commits=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "has_new_commits=true" >> $GITHUB_OUTPUT

          # Check for breaking changes
          if echo "$COMMITS" | grep -q -i "BREAKING CHANGE:" || echo "$COMMITS" | grep -q -i "^break:" || echo "$COMMITS" | grep -q -i "^breaking:"; then
            echo "Major release detected due to breaking changes"
            echo "release_type=major" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check for features
          if echo "$COMMITS" | grep -q -i "^feat:" || echo "$COMMITS" | grep -q -i "^feature:"; then
            echo "Minor release detected due to new features"
            echo "release_type=minor" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Default to patch
          echo "Patch release detected (default for bug fixes, docs, etc.)"
          echo "release_type=patch" >> $GITHUB_OUTPUT

  # Determine the version to use
  determine-version:
    runs-on: ubuntu-latest
    needs: [analyze-commits]
    if: >
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push'
    outputs:
      version: ${{  steps.get-version.outputs.version  }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{  github.token  }}

      - name: Get version
        id: get-version
        run: |
          # If version is provided directly, use it
          if [ "${{  github.event.inputs.version  }}" != "" ]; then
            VERSION="${{  github.event.inputs.version  }}"
            echo "Using provided version: $VERSION"
          else
            # Otherwise calculate it based on the latest tag
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Latest tag: $LATEST_TAG"

            # Remove the 'v' prefix if present
            CURRENT_VERSION="${LATEST_TAG#v}"

            # Default to patch if not otherwise specified
            RELEASE_TYPE="${{  needs.analyze-commits.outputs.release_type || github.event.inputs.release_type || 'patch'  }}"
            RELEASE_TYPE=$(echo "$RELEASE_TYPE" | tr '[:upper:]' '[:lower:]')

            # Split the version
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

            # Increment version based on release type
            if [ "$RELEASE_TYPE" == "major" ]; then
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
            elif [ "$RELEASE_TYPE" == "minor" ]; then
              MINOR=$((MINOR + 1))
              PATCH=0
            else # patch
              PATCH=$((PATCH + 1))
            fi

            VERSION="$MAJOR.$MINOR.$PATCH"
            echo "Calculated new version: $VERSION (using $RELEASE_TYPE bump)"
          fi

          # Validate version format
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Version must follow semantic versioning (X.Y.Z)"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT

  # Prepare the release
  prepare:
    name: Prepare Release
    needs: [determine-version]
    runs-on: ubuntu-latest
    outputs:
      version: ${{  needs.determine-version.outputs.version  }}
      actor: ${{  github.actor  }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{  github.token  }}

      - name: Validate version format
        run: |
          VERSION="${{  needs.determine-version.outputs.version  }}"
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Version must follow semantic versioning (X.Y.Z)"
            exit 1
          fi
          echo "Version format is valid: "$VERSION

      - name: Create release branch
        run: |
          VERSION="${{  needs.determine-version.outputs.version  }}"
          BRANCH="release/v${VERSION}"
          TIMESTAMP=$(date +%s)
          UNIQUE_BRANCH="${BRANCH}-${TIMESTAMP}"

          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          # Set the token for git operations
          GITHUB_TOKEN="${{  github.token  }}"

          # Check if branch already exists remotely
          if git ls-remote --heads origin ${BRANCH} | grep -q ${BRANCH}; then
            echo "Branch ${BRANCH} already exists remotely. Creating a unique branch name."
            BRANCH="${UNIQUE_BRANCH}"
            echo "Using unique branch name: ${BRANCH}"
            git checkout -b "${BRANCH}"
          elif git show-ref --verify --quiet "refs/heads/${BRANCH}"; then
            echo "Branch ${BRANCH} already exists locally. Using existing branch."
            git checkout "${BRANCH}"
          else
            echo "Creating new branch: ${BRANCH}"
            git checkout -b "${BRANCH}"
          fi

          # Update version in files
          echo "Updating version in files to ${VERSION}"

          # Example version update - adjust for your project
          if [ -f "package.json" ]; then
            sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json
            git add package.json
          fi

          if [ -f "frontend/package.json" ]; then
            sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" frontend/package.json
            git add frontend/package.json
          fi

          # Commit changes
          git commit -m "chore: bump version to ${VERSION}" || echo "No changes to commit"

          # Push branch
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git
          git push -u origin "${BRANCH}" --force

          # Store the branch name for later steps
          echo "RELEASE_BRANCH=${BRANCH}" >> $GITHUB_ENV

          echo "Release branch prepared: ${BRANCH}"

      - name: Generate release notes
        id: release_notes
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")

          if [ "$LATEST_TAG" = "none" ]; then
            echo "No previous tag found. Generating release notes for all commits."
            RANGE="HEAD"
          else
            echo "Previous tag found: ${LATEST_TAG}"
            RANGE="${LATEST_TAG}..HEAD"
          fi

          # Generate release notes
          echo "## Changes in this release" > release_notes.md
          echo "" >> release_notes.md

          # Get all commits first
          ALL_COMMITS=$(git log "${RANGE}" --pretty=format:"%s (%h)")

          # Features section
          echo "### Features" >> release_notes.md
          echo "$ALL_COMMITS" | grep -i "^feat" | while read -r line; do
            echo "* $line" >> release_notes.md
          done || true
          echo "" >> release_notes.md

          # Bug fixes section
          echo "### Bug Fixes" >> release_notes.md
          echo "$ALL_COMMITS" | grep -i "^fix" | while read -r line; do
            echo "* $line" >> release_notes.md
          done || true
          echo "" >> release_notes.md

          # Other changes section
          echo "### Other Changes" >> release_notes.md
          echo "$ALL_COMMITS" | grep -v -E "^feat|^fix" | while read -r line; do
            echo "* $line" >> release_notes.md
          done || true
          echo "" >> release_notes.md

          # Display the generated release notes
          cat release_notes.md

          # Save release notes for later steps (only if we're not already in the workspace root)
          if [ "$(pwd)" != "${GITHUB_WORKSPACE}" ]; then
            echo "Copying release notes to workspace root"
            cp release_notes.md "${GITHUB_WORKSPACE}/release_notes.md"
          else
            echo "Already in workspace root, no need to copy release notes"
          fi

  # Trigger component builds
  trigger-builds:
    name: Trigger Component Builds
    needs: [prepare, determine-version]
    runs-on: ubuntu-latest
    steps:
      - name: Trigger API Build
        uses: actions/github-script@v7
        with:
          github-token: ${{  github.token  }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cd-build-api.yaml',
              ref: 'main',
              inputs: {
                go_version: '1.21',
                image_tag: '${{  needs.prepare.outputs.version  }}',
                build_arm: ${{  (github.event.inputs.build_arm == 'true') && 'true' || 'false'  }},
                create_release: 'false'
              }
            });

      - name: Trigger Frontend Build
        uses: actions/github-script@v7
        with:
          github-token: ${{  github.token  }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cd-build-frontend.yaml',
              ref: 'main',
              inputs: {
                node_version: '18',
                image_tag: '${{  needs.prepare.outputs.version  }}',
                build_arm: ${{  (github.event.inputs.build_arm == 'true') && 'true' || 'false'  }}
              }
            });

      - name: Trigger Docker Build
        run: |
          # Standard dispatch payload format that we've tested locally
          echo "Triggering Docker build with version ${{ needs.prepare.outputs.version }}"

          # Use the exact format that worked in our local test
          curl -X POST \
            -H "Authorization: token ${{ github.token }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/dispatches \
            -d '{
              "event_type": "start-docker-build",
              "client_payload": {
                "version": "${{ needs.prepare.outputs.version }}",
                "actor": "${{ needs.prepare.outputs.actor }}",
                "build_arm": false
              }
            }'

          # Check the curl status
          CURL_STATUS=$?
          if [ $CURL_STATUS -ne 0 ]; then
            echo "::error::Failed to trigger Docker build, curl exited with status $CURL_STATUS"
            exit 1
          else
            echo "::notice::Successfully triggered Docker build for version ${{ needs.prepare.outputs.version }}"
          fi

      - name: Build Triggers Summary
        run: |
          {
            echo "## ðŸš€ Component Build Triggers"
            echo "### ðŸ“¦ Triggered Components for v${{  needs.prepare.outputs.version  }}"
            echo "| Component | Status |"
            echo "| --- | --- |"
            echo "| ðŸ–¥ï¸ **API** | âœ… Triggered |"
            echo "| ðŸŒ **Frontend** | âœ… Triggered |"
            echo "| ðŸ³ **Docker** | âœ… Triggered |"
            echo ""
            echo "All builds will use version ${{  needs.prepare.outputs.version  }}"
          } >> "$GITHUB_STEP_SUMMARY"

  # Create GitHub Release if requested
  github-release:
    name: Create GitHub Release
    needs: [prepare, determine-version, trigger-builds]
    if: >
      (github.event_name == 'workflow_dispatch' && github.event.inputs.create_github_release == 'true') ||
      github.event_name == 'push'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{  env.RELEASE_BRANCH || format('release/v{0}', needs.prepare.outputs.version)  }}
          token: ${{  github.token  }}

      - name: Get release notes
        run: |
          # Generate a basic release notes file if it doesn't exist
          if [ ! -f "release_notes.md" ]; then
            echo "Creating a new release notes file"
            echo "## Release v${{  needs.prepare.outputs.version  }}" > release_notes.md
            echo "" >> release_notes.md
            echo "This release includes updates and improvements." >> release_notes.md
            echo "" >> release_notes.md
            echo "Full changelog can be auto-generated by GitHub." >> release_notes.md
          else
            echo "Using existing release notes file"
          fi
          # Display the release notes
          cat release_notes.md

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{  needs.prepare.outputs.version  }}
          name: Release v${{  needs.prepare.outputs.version  }}
          body_path: release_notes.md
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{  github.token  }}

      - name: Generate release summary
        run: |
          {
            echo "## ðŸš€ GitHub Release Created"
            echo "| Property | Value |"
            echo "| --- | --- |"
            echo "| ðŸ·ï¸ **Version** | v${{  needs.prepare.outputs.version  }} |"
            echo "| ðŸ‘¤ **Created by** | @${{  needs.prepare.outputs.actor  }} |"
            echo -n "| ðŸ”— **Release URL** | "
            echo -n "[${{  github.repository  }}/releases/tag/v${{  needs.prepare.outputs.version  }}]"
            echo "(${{  github.server_url  }}/${{  github.repository  }}/releases/tag/v${{  needs.prepare.outputs.version  }}) |"
          } >> "$GITHUB_STEP_SUMMARY"

  # Deploy artifacts if requested
  deploy:
    name: Deploy Artifacts
    needs: [prepare, github-release, determine-version, trigger-builds]
    if: >
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_artifacts == 'true' && github.event.inputs.create_github_release == 'true') ||
      github.event_name == 'push'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{  env.RELEASE_BRANCH || format('release/v{0}', needs.prepare.outputs.version)  }}
          token: ${{  github.token  }}

      - name: Deploy to staging
        run: |
          echo "Deploying version ${{  needs.prepare.outputs.version  }} to staging environment"
          # Add your deployment commands here

          {
            echo "## ðŸš€ Deployment Summary"
            echo "| Property | Value |"
            echo "| --- | --- |"
            echo "| ðŸ·ï¸ **Version** | v${{  needs.prepare.outputs.version  }} |"
            echo "| ðŸŒ **Environment** | Staging |"
            echo "| ðŸ‘¤ **Deployed by** | @${{  needs.prepare.outputs.actor  }} |"
            echo "| ðŸ•’ **Deployment Date** | $(date) |"
          } >> "$GITHUB_STEP_SUMMARY"

  # Handle build completion notification
  handle-build-complete:
    name: Handle Build Completion
    if: github.event_name == 'repository_dispatch' && github.event.action == 'docker-build-complete'
    runs-on: ubuntu-latest
    steps:
      - name: Process build completion
        run: |
          echo "Received build completion notification"
          echo "Version: ${{  github.event.client_payload.version  }}"
          echo "Actor: ${{  github.event.client_payload.actor  }}"

          {
            echo "## ðŸ Build Completion Notification"
            echo "| Property | Value |"
            echo "| --- | --- |"
            echo "| ðŸ·ï¸ **Version** | v${{  github.event.client_payload.version  }} |"
            echo "| ðŸ‘¤ **Built by** | @${{  github.event.client_payload.actor  }} |"
            echo "| ðŸ•’ **Received** | $(date) |"
            echo "| ðŸ”„ **Event** | docker-build-complete |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Finalize release
        run: |
          echo "Finalizing release v${{  github.event.client_payload.version  }}"
          # Add any finalization steps here

          {
            echo "## ðŸŽ‰ Release Finalized"
            echo "Release v${{  github.event.client_payload.version  }} is now complete!"
            echo ""
            echo "All components have been built and deployed:"
            echo "- âœ… API"
            echo "- âœ… Frontend"
            echo "- âœ… Docker images"
            echo ""
            echo "The release is now available for use."
          } >> "$GITHUB_STEP_SUMMARY"
