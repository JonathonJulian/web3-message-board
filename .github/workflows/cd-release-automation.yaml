---
name: Release Automation
run-name: ${{  github.event.inputs.release_type || 'Auto'  }} Release ${{  github.event.inputs.version && format('v{0}', github.event.inputs.version) || '(version to be determined)'  }}

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g. 1.0.0)"
        required: false
        type: string
      release_type:
        description: "Type of release"
        type: choice
        options:
          - Major
          - Minor
          - Patch
        default: "Patch"
        required: true
      create_github_release:
        description: "Create GitHub Release"
        type: boolean
        default: true
      deploy_artifacts:
        description: "Deploy artifacts"
        type: boolean
        default: true
      build_docker:
        description: "Build Docker images"
        type: boolean
        default: true
      build_arm:
        description: "Build ARM64 architecture"
        type: boolean
        default: false

# Add explicit write permissions
permissions:
  contents: write
  pull-requests: write
  discussions: write
  actions: write

jobs:
  # Analyze commits to determine version bump type
  analyze-commits:
    runs-on: ubuntu-latest
    outputs:
      release_type: ${{  steps.analyze.outputs.release_type  }}
      has_new_commits: ${{  steps.analyze.outputs.has_new_commits  }}
    if: github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{  github.token  }}

      - name: Analyze commits for release type
        id: analyze
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Get commit messages since the latest tag
          COMMITS=$(git log --pretty=format:"%s" $LATEST_TAG..HEAD)
          COMMIT_COUNT=$(echo "$COMMITS" | grep -v "^$" | wc -l | xargs)
          echo "Found $COMMIT_COUNT new commits since $LATEST_TAG"

          echo "Commit messages since last tag:"
          git log --pretty=format:"%h - %s" $LATEST_TAG..HEAD

          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "No new commits found"
            echo "has_new_commits=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "has_new_commits=true" >> $GITHUB_OUTPUT

          # Check for breaking changes
          if echo "$COMMITS" | grep -q -i "BREAKING CHANGE:" || echo "$COMMITS" | grep -q -i "^break:" || echo "$COMMITS" | grep -q -i "^breaking:"; then
            echo "Major release detected due to breaking changes"
            echo "release_type=major" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check for features
          if echo "$COMMITS" | grep -q -i "^feat:" || echo "$COMMITS" | grep -q -i "^feature:"; then
            echo "Minor release detected due to new features"
            echo "release_type=minor" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Default to patch
          echo "Patch release detected (default for bug fixes, docs, etc.)"
          echo "release_type=patch" >> $GITHUB_OUTPUT

  # Determine the version to use
  determine-version:
    runs-on: ubuntu-latest
    needs: [analyze-commits]
    if: >
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push'
    outputs:
      version: ${{  steps.get-version.outputs.version  }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{  github.token  }}

      - name: Get version
        id: get-version
        run: |
          # If version is provided directly, use it
          if [ "${{  github.event.inputs.version  }}" != "" ]; then
            VERSION="${{  github.event.inputs.version  }}"
            echo "Using provided version: $VERSION"
          else
            # Otherwise calculate it based on the latest tag
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Latest tag: $LATEST_TAG"

            # Remove the 'v' prefix if present
            CURRENT_VERSION="${LATEST_TAG#v}"

            # Default to patch if not otherwise specified
            RELEASE_TYPE="${{  needs.analyze-commits.outputs.release_type || github.event.inputs.release_type || 'patch'  }}"
            RELEASE_TYPE=$(echo "$RELEASE_TYPE" | tr '[:upper:]' '[:lower:]')

            # Split the version
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

            # Increment version based on release type
            if [ "$RELEASE_TYPE" == "major" ]; then
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
            elif [ "$RELEASE_TYPE" == "minor" ]; then
              MINOR=$((MINOR + 1))
              PATCH=0
            else # patch
              PATCH=$((PATCH + 1))
            fi

            VERSION="$MAJOR.$MINOR.$PATCH"
            echo "Calculated new version: $VERSION (using $RELEASE_TYPE bump)"
          fi

          # Validate version format
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Version must follow semantic versioning (X.Y.Z)"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT

  # Prepare the release
  prepare:
    name: Prepare Release
    needs: [determine-version]
    runs-on: ubuntu-latest
    outputs:
      version: ${{  needs.determine-version.outputs.version  }}
      actor: ${{  github.actor  }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{  github.token  }}

      - name: Validate version format
        run: |
          VERSION="${{  needs.determine-version.outputs.version  }}"
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Version must follow semantic versioning (X.Y.Z)"
            exit 1
          fi
          echo "Version format is valid: "$VERSION

      - name: Create release branch
        run: |
          VERSION="${{  needs.determine-version.outputs.version  }}"
          BRANCH="release/v${VERSION}"
          TIMESTAMP=$(date +%s)
          UNIQUE_BRANCH="${BRANCH}-${TIMESTAMP}"

          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          # Set the token for git operations
          GITHUB_TOKEN="${{  github.token  }}"

          # Check if branch already exists remotely
          if git ls-remote --heads origin ${BRANCH} | grep -q ${BRANCH}; then
            echo "Branch ${BRANCH} already exists remotely. Creating a unique branch name."
            BRANCH="${UNIQUE_BRANCH}"
            echo "Using unique branch name: ${BRANCH}"
            git checkout -b "${BRANCH}"
          elif git show-ref --verify --quiet "refs/heads/${BRANCH}"; then
            echo "Branch ${BRANCH} already exists locally. Using existing branch."
            git checkout "${BRANCH}"
          else
            echo "Creating new branch: ${BRANCH}"
            git checkout -b "${BRANCH}"
          fi

          # Update version in files
          echo "Updating version in files to ${VERSION}"

          # Example version update - adjust for your project
          if [ -f "package.json" ]; then
            sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json
            git add package.json
          fi

          if [ -f "frontend/package.json" ]; then
            sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" frontend/package.json
            git add frontend/package.json
          fi

          # Commit changes
          git commit -m "chore: bump version to ${VERSION}" || echo "No changes to commit"

          # Push branch
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git
          git push -u origin "${BRANCH}" --force

          # Store the branch name for later steps
          echo "RELEASE_BRANCH=${BRANCH}" >> $GITHUB_ENV

          echo "Release branch prepared: ${BRANCH}"

      - name: Generate release notes
        id: release_notes
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")

          if [ "$LATEST_TAG" = "none" ]; then
            echo "No previous tag found. Generating release notes for all commits."
            RANGE="HEAD"
          else
            echo "Previous tag found: ${LATEST_TAG}"
            RANGE="${LATEST_TAG}..HEAD"
          fi

          # Generate release notes
          echo "## Changes in this release" > release_notes.md
          echo "" >> release_notes.md

          # Get all commits first
          ALL_COMMITS=$(git log "${RANGE}" --pretty=format:"%s (%h)")

          # Features section
          echo "### Features" >> release_notes.md
          echo "$ALL_COMMITS" | grep -i "^feat" | while read -r line; do
            echo "* $line" >> release_notes.md
          done || true
          echo "" >> release_notes.md

          # Bug fixes section
          echo "### Bug Fixes" >> release_notes.md
          echo "$ALL_COMMITS" | grep -i "^fix" | while read -r line; do
            echo "* $line" >> release_notes.md
          done || true
          echo "" >> release_notes.md

          # Other changes section
          echo "### Other Changes" >> release_notes.md
          echo "$ALL_COMMITS" | grep -v -E "^feat|^fix" | while read -r line; do
            echo "* $line" >> release_notes.md
          done || true
          echo "" >> release_notes.md

          # Display the generated release notes
          cat release_notes.md

          # Save release notes for later steps (only if we're not already in the workspace root)
          if [ "$(pwd)" != "${GITHUB_WORKSPACE}" ]; then
            echo "Copying release notes to workspace root"
            cp release_notes.md "${GITHUB_WORKSPACE}/release_notes.md"
          else
            echo "Already in workspace root, no need to copy release notes"
          fi

  # Trigger component builds
  trigger-builds:
    name: Trigger Component Builds
    needs: [prepare, determine-version]
    runs-on: ubuntu-latest
    outputs:
      api_workflow_id: ${{ steps.trigger_api.outputs.workflow_id }}
      frontend_workflow_id: ${{ steps.trigger_frontend.outputs.workflow_id }}
    steps:
      - name: Trigger API Build
        id: trigger_api
        uses: actions/github-script@v7
        with:
          github-token: ${{  github.token  }}
          script: |
            const response = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cd-build-api.yaml',
              ref: 'main',
              inputs: {
                image_tag: '${{  needs.prepare.outputs.version  }}',
                build_arm: ${{  (github.event.inputs.build_arm == 'true') && 'true' || 'false'  }},
                create_release: 'true'
              }
            });

            // Wait for workflow to be dispatched
            await new Promise(resolve => setTimeout(resolve, 3000));

            // Get the workflow run ID
            const workflowRuns = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cd-build-api.yaml',
              per_page: 1
            });

            if (workflowRuns.data.workflow_runs.length > 0) {
              const workflowId = workflowRuns.data.workflow_runs[0].id;
              console.log(`API build triggered with workflow ID: ${workflowId}`);
              core.setOutput('workflow_id', workflowId);
            } else {
              console.log('Could not find workflow run ID for API build');
              core.setOutput('workflow_id', '');
            }

      - name: Trigger Frontend Build
        id: trigger_frontend
        uses: actions/github-script@v7
        with:
          github-token: ${{  github.token  }}
          script: |
            const response = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cd-build-frontend.yaml',
              ref: 'main',
              inputs: {
                node_version: '20',
                image_tag: '${{  needs.prepare.outputs.version  }}',
                create_release: 'true'
              }
            });

            // Wait for workflow to be dispatched
            await new Promise(resolve => setTimeout(resolve, 3000));

            // Get the workflow run ID
            const workflowRuns = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cd-build-frontend.yaml',
              per_page: 1
            });

            if (workflowRuns.data.workflow_runs.length > 0) {
              const workflowId = workflowRuns.data.workflow_runs[0].id;
              console.log(`Frontend build triggered with workflow ID: ${workflowId}`);
              core.setOutput('workflow_id', workflowId);
            } else {
              console.log('Could not find workflow run ID for Frontend build');
              core.setOutput('workflow_id', '');
            }

      - name: Build Triggers Summary
        run: |
          {
            echo "## ðŸš€ Component Build Triggers"
            echo "### ðŸ“¦ Triggered Components for v${{  needs.prepare.outputs.version  }}"
            echo "| Component | Status |"
            echo "| --- | --- |"
            echo "| ðŸ–¥ï¸ **API** | âœ… Triggered |"
            echo "| ðŸŒ **Frontend** | âœ… Triggered |"
            echo ""
            echo "All builds will use version ${{  needs.prepare.outputs.version  }}"
          } >> "$GITHUB_STEP_SUMMARY"

  # Wait for component builds to complete
  wait-for-builds:
    name: Wait for Component Builds
    needs: [prepare, determine-version, trigger-builds]
    runs-on: ubuntu-latest
    steps:
      - name: Wait for API Build
        if: needs.trigger-builds.outputs.api_workflow_id != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{  github.token  }}
          script: |
            const workflowId = '${{ needs.trigger-builds.outputs.api_workflow_id }}';

            if (!workflowId) {
              console.log('No API workflow ID provided, skipping wait');
              return;
            }

            console.log(`Waiting for API build with workflow ID: ${workflowId}`);

            // Poll every 30 seconds for up to 15 minutes
            for (let i = 0; i < 30; i++) {
              const { data: run } = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: workflowId
              });

              console.log(`API build status: ${run.status}, conclusion: ${run.conclusion}`);

              if (run.status === 'completed') {
                if (run.conclusion === 'success') {
                  console.log('API build completed successfully');
                  break;
                } else {
                  throw new Error(`API build failed with conclusion: ${run.conclusion}`);
                }
              }

              // Wait 30 seconds before checking again
              await new Promise(resolve => setTimeout(resolve, 30000));
            }

      - name: Wait for Frontend Build
        if: needs.trigger-builds.outputs.frontend_workflow_id != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{  github.token  }}
          script: |
            const workflowId = '${{ needs.trigger-builds.outputs.frontend_workflow_id }}';

            if (!workflowId) {
              console.log('No Frontend workflow ID provided, skipping wait');
              return;
            }

            console.log(`Waiting for Frontend build with workflow ID: ${workflowId}`);

            // Poll every 30 seconds for up to 15 minutes
            for (let i = 0; i < 30; i++) {
              const { data: run } = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: workflowId
              });

              console.log(`Frontend build status: ${run.status}, conclusion: ${run.conclusion}`);

              if (run.status === 'completed') {
                if (run.conclusion === 'success') {
                  console.log('Frontend build completed successfully');
                  break;
                } else {
                  throw new Error(`Frontend build failed with conclusion: ${run.conclusion}`);
                }
              }

              // Wait 30 seconds before checking again
              await new Promise(resolve => setTimeout(resolve, 30000));
            }

  # Create GitHub Release with all artifacts
  github-release:
    name: Create GitHub Release
    needs: [prepare, determine-version, wait-for-builds]
    if: >
      (github.event_name == 'workflow_dispatch' && github.event.inputs.create_github_release == 'true') ||
      github.event_name == 'push'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{  env.RELEASE_BRANCH || format('release/v{0}', needs.prepare.outputs.version)  }}
          token: ${{  github.token  }}

      - name: Download API artifacts
        uses: actions/github-script@v7
        with:
          github-token: ${{  github.token  }}
          script: |
            // Get the latest successful run of the API build workflow
            const workflowRuns = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cd-build-api.yaml',
              status: 'success',
              per_page: 1
            });

            if (workflowRuns.data.workflow_runs.length === 0) {
              console.log('No successful API build found');
              return;
            }

            const runId = workflowRuns.data.workflow_runs[0].id;
            console.log(`Found API build run ID: ${runId}`);

            // Get artifacts from the workflow run
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });

            // Download each artifact
            for (const artifact of artifacts.data.artifacts) {
              console.log(`Downloading artifact: ${artifact.name}`);

              const download = await github.rest.actions.downloadArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: artifact.id,
                archive_format: 'zip'
              });

              const fs = require('fs');
              fs.writeFileSync(`${artifact.name}.zip`, Buffer.from(download.data));

              // Extract the zip file
              const { execSync } = require('child_process');
              execSync(`mkdir -p artifacts && unzip -o ${artifact.name}.zip -d artifacts/`);
            }

      - name: Download Frontend artifacts
        uses: actions/github-script@v7
        with:
          github-token: ${{  github.token  }}
          script: |
            // Get the latest successful run of the Frontend build workflow
            const workflowRuns = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cd-build-frontend.yaml',
              status: 'success',
              per_page: 1
            });

            if (workflowRuns.data.workflow_runs.length === 0) {
              console.log('No successful Frontend build found');
              return;
            }

            const runId = workflowRuns.data.workflow_runs[0].id;
            console.log(`Found Frontend build run ID: ${runId}`);

            // Get artifacts from the workflow run
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });

            // Download each artifact
            for (const artifact of artifacts.data.artifacts) {
              console.log(`Downloading artifact: ${artifact.name}`);

              const download = await github.rest.actions.downloadArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: artifact.id,
                archive_format: 'zip'
              });

              const fs = require('fs');
              fs.writeFileSync(`${artifact.name}.zip`, Buffer.from(download.data));

              // Extract the zip file
              const { execSync } = require('child_process');
              execSync(`mkdir -p artifacts && unzip -o ${artifact.name}.zip -d artifacts/`);
            }

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{  needs.prepare.outputs.version  }}
          name: Release v${{  needs.prepare.outputs.version  }}
          body_path: release_notes.md
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            artifacts/*
        env:
          GITHUB_TOKEN: ${{  github.token  }}

      - name: Generate release summary
        run: |
          {
            echo "## ðŸš€ GitHub Release Created"
            echo "| Property | Value |"
            echo "| --- | --- |"
            echo "| ðŸ·ï¸ **Version** | v${{  needs.prepare.outputs.version  }} |"
            echo "| ðŸ‘¤ **Created by** | @${{  needs.prepare.outputs.actor  }} |"
            echo -n "| ðŸ”— **Release URL** | "
            echo -n "[${{  github.repository  }}/releases/tag/v${{  needs.prepare.outputs.version  }}]"
            echo "(${{  github.server_url  }}/${{  github.repository  }}/releases/tag/v${{  needs.prepare.outputs.version  }}) |"
          } >> "$GITHUB_STEP_SUMMARY"

  # Deploy artifacts if requested
  deploy:
    name: Deploy Artifacts
    needs: [prepare, github-release, determine-version]
    if: >
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_artifacts == 'true' && github.event.inputs.create_github_release == 'true') ||
      github.event_name == 'push'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{  env.RELEASE_BRANCH || format('release/v{0}', needs.prepare.outputs.version)  }}
          token: ${{  github.token  }}

      - name: Deploy to staging
        run: |
          echo "Deploying version ${{  needs.prepare.outputs.version  }} to staging environment"
          # Add your deployment commands here

          {
            echo "## ðŸš€ Deployment Summary"
            echo "| Property | Value |"
            echo "| --- | --- |"
            echo "| ðŸ·ï¸ **Version** | v${{  needs.prepare.outputs.version  }} |"
            echo "| ðŸŒ **Environment** | Staging |"
            echo "| ðŸ‘¤ **Deployed by** | @${{  needs.prepare.outputs.actor  }} |"
            echo "| ðŸ•’ **Deployment Date** | $(date) |"
          } >> "$GITHUB_STEP_SUMMARY"
